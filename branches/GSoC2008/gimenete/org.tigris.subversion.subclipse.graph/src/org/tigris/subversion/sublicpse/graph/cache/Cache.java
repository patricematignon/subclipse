package org.tigris.subversion.sublicpse.graph.cache;

import java.io.File;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Types;
import java.text.MessageFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.tigris.subversion.svnclientadapter.ISVNLogMessage;
import org.tigris.subversion.svnclientadapter.ISVNLogMessageChangePath;

public class Cache {

	private static final String DRIVER_CLASS_NAME = "org.apache.derby.jdbc.EmbeddedDriver";
	
	private Connection connection;

	private PreparedStatement insertRevision;
	private PreparedStatement insertFile;
	private PreparedStatement insertCopyFile;
	private PreparedStatement insertChangePath;
	private PreparedStatement deleteFile;
	private PreparedStatement selectFiles;
	
	public Cache(File f) {
		try {
			String databaseName = f.toURL().toString().substring("file:/".length());

			Class.forName(DRIVER_CLASS_NAME);
			try {
				connection = 
					DriverManager.getConnection("jdbc:derby:"+databaseName);
			} catch(SQLException e) {
				// The database may not exist.
				connection = 
					DriverManager.getConnection("jdbc:derby:"+databaseName+";create=true");
				// Create tables
				createTablesAndIndexes();
			}
		} catch(Exception e) {
			throw new CacheException("Error creating cache", e);
		}
	}
	
	private void createTablesAndIndexes() throws Exception {
		String s = "CREATE TABLE files (" +
				"file_id BIGINT NOT NULL GENERATED BY DEFAULT AS IDENTITY (START WITH 1, INCREMENT BY 1), " +
				"revision_from BIGINT NOT NULL, " +
				"revision_to BIGINT, " +
				"path VARCHAR(32672) NOT NULL)";
		
		executeUpdate(s);

		s = "CREATE TABLE revisions (" +
				"revision_id BIGINT NOT NULL, " +
				"revision_date TIMESTAMP NOT NULL, " +
				"author VARCHAR(32672) NOT NULL, " +
				"message VARCHAR(32672) NOT NULL, " +
				"PRIMARY KEY (revision_id))";

		executeUpdate(s);

		s = "CREATE TABLE change_paths (" +
				"path VARCHAR(32672) NOT NULL, " +
				"revision_id BIGINT NOT NULL, " +
				"copy_src_revision BIGINT, " +
				"copy_src_path VARCHAR(32672), " +
				"action CHAR(1) NOT NULL, " +
				"file_id BIGINT NOT NULL)";
//				"PRIMARY KEY (revision_id, path, action))"; // We can have an A and M change_path from the same path in the same revision
		
		executeUpdate(s);

		s = "ALTER TABLE change_paths ADD CONSTRAINT fk_change_revision " +
				"FOREIGN KEY (revision_id) REFERENCES revisions (revision_id)";
		
		executeUpdate(s);

		s = "CREATE INDEX files_revision_from ON files (revision_from)";
		
		executeUpdate(s);

		s = "CREATE INDEX files_revision_to ON files (revision_to)";
		
		executeUpdate(s);

		s = "CREATE INDEX files_path ON files (path)";
		
		executeUpdate(s);

		s = "CREATE INDEX files_file_id ON files (file_id)";
		
		executeUpdate(s);
		
	}
	
	public void close() {
		closeStatement(insertRevision);
		closeStatement(insertFile);
		closeStatement(insertCopyFile);
		closeStatement(insertChangePath);
		closeStatement(deleteFile);
		closeStatement(selectFiles);
		
		try {
			connection.close();
		} catch (SQLException e) {
			throw new CacheException("Error closing database connection", e);
		}
	}
	
	private void closeStatement(PreparedStatement statement) {
		if(statement != null) {
			try {
				statement.close();
			} catch (SQLException e) {
				throw new CacheException("Error closing statement", e);
			}
		}
	}
	
	private void closeResultSet(ResultSet result) {
		if(result != null) {
			try {
				result.close();
			} catch (SQLException e) {
				throw new CacheException("Error closing ResultSet", e);
			}
		}
	}

	private void insertRevision(long revision, Date revisionDate, String author, String message) {
		if(insertRevision == null) {
			try {
			insertRevision = connection.prepareStatement("INSERT INTO revisions (" +
						"revision_id, " +
						"revision_date, " +
						"author, " +
						"message" +
						") VALUES (?, ?, ?, ?)",
						ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY);
			} catch(SQLException e) {
				throw new CacheException("Cannot create insertRevision statement", e);
			}
		}
		
		try {
			insertRevision.setLong(1, revision);
			insertRevision.setTimestamp(2, new java.sql.Timestamp(revisionDate.getTime()));
			insertRevision.setString(3, author);
			insertRevision.setString(4, message);
			insertRevision.executeUpdate();
		} catch(SQLException e) {
			throw new CacheException("Error inserting revision", e);
		}
	}
	
	private long insertFile(long revFrom, String path) {
		if(insertFile == null) {
			try {
				insertFile = connection.prepareStatement("INSERT INTO files (" +
					"revision_from, " +
					"path" +
					") VALUES (?, ?)", PreparedStatement.RETURN_GENERATED_KEYS);
			} catch(SQLException e) {
				throw new CacheException("Cannot create insertFile statement", e);
			}
		}
		
		ResultSet result = null;
		try {
			insertFile.setLong(1, revFrom);
			insertFile.setString(2, path);
			insertFile.executeUpdate();
			
			result = insertFile.getGeneratedKeys();
			if(result != null && result.next()) {
				return result.getLong(1);
			} else {
				throw new CacheException("Not generated key for inserted file");
			}
		} catch(SQLException e) {
			throw new CacheException("Error inserting revision", e);
		} finally {
			closeResultSet(result);
		}
	}
	
	private void insertCopyFile(long fileId, long revision, String path) {
		if(insertCopyFile == null) {
			try {
				insertCopyFile = connection.prepareStatement("INSERT INTO files (" +
					"file_id, "+
					"revision_from, " +
					"path" +
					") VALUES (?, ?, ?)",
					ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY);
			} catch(SQLException e) {
				throw new CacheException("Cannot create insertCopyFile statement", e);
			}
		}
		
		try {
			insertCopyFile.setLong(1, fileId);
			insertCopyFile.setLong(2, revision);
			insertCopyFile.setString(3, path);
			insertCopyFile.executeUpdate();
		} catch(SQLException e) {
			throw new CacheException("Error inserting file branched", e);
		}
	}
	
	private void insertChangePath(long revision, Long copySrcRevision, String copySrcPath, char action, long fileId, String path) {
		if(insertChangePath == null) {
			try {
				insertChangePath = connection.prepareStatement("INSERT INTO change_paths (" +
						"revision_id, " +
						"copy_src_revision, " +
						"copy_src_path, " +
						"action, " +
						"file_id, " +
						"path" +
						") VALUES (?, ?, ?, ?, ?, ?)",
						ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY);
			} catch(SQLException e) {
				throw new CacheException("Cannot create insertChangePath statement", e);
			}
		}
		
		try {
			insertChangePath.setLong(1, revision);
			if(copySrcRevision == null) {
				insertChangePath.setNull(2, Types.BIGINT);
			} else {
				insertChangePath.setLong(2, copySrcRevision.longValue());
			}
			insertChangePath.setString(3, copySrcPath);
			insertChangePath.setString(4, Character.toString(action));
			insertChangePath.setLong(5, fileId);
			insertChangePath.setString(6, path);
			insertChangePath.executeUpdate();
		} catch(SQLException e) {
			System.err.println(revision+" at "+path+" "+action);
			throw new CacheException("Error inserting change path", e);
		}
	}
	
	private void deleteFile(Map fileIds, long revision, long fileId, String path, boolean recursive) {
		if(deleteFile == null) {
			try {
				deleteFile = connection.prepareStatement("UPDATE files SET revision_to=? WHERE file_id=? AND path=?");
			} catch(SQLException e) {
				throw new CacheException("Cannot create deleteFile statement", e);
			}
		}
		
		try {
			deleteFile.setLong(1, revision);
			deleteFile.setLong(2, fileId);
			deleteFile.setString(3, path);
			deleteFile.executeUpdate();
		} catch(SQLException e) {
			throw new CacheException("Error deleting file", e);
		}
		
		if(!recursive) return;
		
		fileIds.remove(path);
		PreparedStatement selectFiles = null;
		PreparedStatement delete = null;
		ResultSet resultSet = null;
		try {
			selectFiles = connection.prepareStatement("SELECT path FROM files WHERE revision_to IS NULL AND path LIKE ?",
					ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY);
			selectFiles.setString(1, path+"/%");
			resultSet = selectFiles.executeQuery();
			while(resultSet.next()) {
				String p = resultSet.getString(1);
				fileIds.remove(p);
			}

			delete = connection.prepareStatement("UPDATE files SET revision_to=? WHERE revision_to IS NULL AND path LIKE ?");
			delete.setLong(1, revision);
			delete.setString(2, path+"/%");
			delete.executeUpdate();
		} catch(SQLException e) {
			throw new CacheException("Error while deleting subfiles", e);
		} finally {
			closeStatement(selectFiles);
			closeStatement(delete);
			closeResultSet(resultSet);
		}
	}
	
	private void initSelectFiles() {
		if(selectFiles == null) {
			try {
				selectFiles = connection.prepareStatement("SELECT path, file_id FROM files WHERE revision_from <=? AND (revision_to IS NULL OR revision_to>?) AND path LIKE ?");
			} catch(SQLException e) {
				throw new CacheException("Cannot create selectFiles statement", e);
			}
		}
	}
	
	private void addSubfiles(Map fileIds, String copySrcPath, String path, char action, long copySrcRevision, long revision, boolean ignoreIfAlreadyExists) {
		// anything with copy_src_path/something has a branch in path/something
		initSelectFiles();
		try {
			selectFiles.setLong(1, copySrcRevision);
			selectFiles.setLong(2, copySrcRevision);
			selectFiles.setString(3, copySrcPath+"/%");

			int length = copySrcPath.length();
			ResultSet r = selectFiles.executeQuery();
//			System.out.println("calculating branches. "+path+" from "+copySrcPath);
			while(r.next()) {
				String fromPath = r.getString(1);
				long fileId = r.getLong(2);
				String finalPath = path + fromPath.substring(length);
//				System.out.println(finalPath);
				
				Long id = getFileId(finalPath, revision);
				if(id == null) {
					insertCopyFile(fileId, revision, finalPath);
					fileIds.put(finalPath, new Long(fileId));

					insertChangePath(revision, 
							new Long(copySrcRevision), 
							fromPath, 
							action, 
							fileId, 
							finalPath);
				} else {
					if(!ignoreIfAlreadyExists) {
						System.err.println(finalPath+" at "+revision+" already exists");
						System.err.println("when calculating branches for copy of "+path+" from "+fromPath);
						/*
						try {
							PreparedStatement st = connection.prepareStatement("SELECT file_id, revision_from, revision_to, path FROM files WHERE file_id=? OR path=?");
							st.setLong(1, id.longValue());
							st.setString(2, finalPath);
							ResultSet result = st.executeQuery();
							while(result.next()) {
								System.err.println(MessageFormat.format("{0} {1}:{2} {3}", new Object[]{
										new Long(result.getLong(1)),
										new Long(result.getLong(2)),
										new Long(result.getLong(3)),
										result.getString(4)
								}));
							}
						} catch(SQLException ex) {
							ex.printStackTrace();
						}
						*/

//						throw new CacheException();
					} else {
//						System.out.println("...");
					}
				}
			}
		} catch(SQLException e) {
			throw new CacheException("Error calculating branches", e);
		}
	}
	
	public void update(ISVNLogMessage[] messages) throws Exception {
		Map fileIds = new HashMap();
		
		for (int i = 0; i < messages.length; i++) {
			ISVNLogMessage logMessage = messages[i];
			long revision = logMessage.getRevision().getNumber();
			insertRevision(revision,
					logMessage.getDate(),
					logMessage.getAuthor(),
					logMessage.getMessage());
			
			ISVNLogMessageChangePath[] changedPaths = logMessage.getChangedPaths();
			for (int j = 0; j < changedPaths.length; j++) {
				ISVNLogMessageChangePath changePath = changedPaths[j];
				
				Long copySrcRevision = null;
				if(changePath.getCopySrcRevision() != null) {
					copySrcRevision = new Long(changePath.getCopySrcRevision().getNumber());
				}
				
				switch(changePath.getAction()) {
				case 'A':
					addedAction(changePath, fileIds, revision, copySrcRevision);
					break;
				case 'M':
					modifiedAction(changePath, fileIds, revision, copySrcRevision);
					break;
				case 'D':
					deletedAction(changePath, fileIds, revision, copySrcRevision, true);
					break;
				case 'R':
					deletedAction(changePath, fileIds, revision, copySrcRevision, false);
					addedAction(changePath, fileIds, revision, copySrcRevision);
					continue;
				default:
					System.err.println("Unknown action: "+changePath.getAction());
				}
			}
		}
	}
	
	private void addedAction(ISVNLogMessageChangePath changePath, Map fileIds, long revision, Long copySrcRevision) throws Exception {
		long fileId = 0;
		char action = 'A';
		if(changePath.getCopySrcRevision() == null) {
			fileId = insertFile(revision, changePath.getPath());
			fileIds.put(changePath.getPath(), new Long(fileId));
		} else {
			Long l = getFileId(changePath.getCopySrcPath(), changePath.getCopySrcRevision().getNumber());
			if(l == null) {
				System.err.println(changePath.getCopySrcPath()+" not found at revision "+changePath.getCopySrcRevision().getNumber());
				System.err.println(changePath.getPath());
				
				PreparedStatement st = connection.prepareStatement("SELECT file_id, revision_from, revision_to, path FROM files WHERE path LIKE ?");
				st.setString(1, changePath.getCopySrcPath());
				ResultSet result = st.executeQuery();
				while(result.next()) {
					System.err.println(MessageFormat.format("{0} {1}:{2} {3}", new Object[]{
							new Long(result.getLong(1)),
							new Long(result.getLong(2)),
							new Long(result.getLong(3)),
							result.getString(4)
					}));
				}
			}
			fileId = l.longValue();
			insertCopyFile(fileId, revision, changePath.getPath());
			fileIds.put(changePath.getPath(), new Long(fileId));
			
			boolean ignoreIfAlreadyExists = changePath.getAction() == 'R';
//			if(changePath.getAction() == 'A') { // not if R
				addSubfiles(fileIds, 
						changePath.getCopySrcPath(), 
						changePath.getPath(), 
						action, 
						changePath.getCopySrcRevision().getNumber(), 
						revision,
						ignoreIfAlreadyExists);
//			}
		}
		
		insertChangePath(revision, 
				copySrcRevision,
				changePath.getCopySrcPath(), 
				action,
				fileId, 
				changePath.getPath());
	}
	
	private void modifiedAction(ISVNLogMessageChangePath changePath, Map fileIds, long revision, Long copySrcRevision) {
		long fileId = getFileId(fileIds, changePath.getPath(), revision);
		insertChangePath(revision, 
				copySrcRevision, 
				changePath.getCopySrcPath(), 
				changePath.getAction(),
				fileId, 
				changePath.getPath());
	}
	
	private void deletedAction(ISVNLogMessageChangePath changePath, Map fileIds, 
			long revision, Long copySrcRevision, boolean recursive) {
		long fileId = getFileId(fileIds, changePath.getPath(), revision);
		deleteFile(fileIds, revision, fileId, changePath.getPath(), recursive);
		insertChangePath(revision, 
				copySrcRevision, 
				changePath.getCopySrcPath(), 
				'D',
				fileId, 
				changePath.getPath());
	}
	
	private long getFileId(Map fileIds, String path, long revision) {
		Long l = ((Long) fileIds.get(path));
		if(l == null) {
			l = getFileId(path, revision);
			if(l == null) {
				System.err.println(path+" not in revision "+revision);
				
				try {
					PreparedStatement st = connection.prepareStatement("SELECT file_id, revision_from, revision_to, path FROM files WHERE path LIKE ?");
					st.setString(1, path);
					ResultSet result = st.executeQuery();
					while(result.next()) {
						System.err.println(MessageFormat.format("{0} {1}:{2} {3}", new Object[]{
								new Long(result.getLong(1)),
								new Long(result.getLong(2)),
								new Long(result.getLong(3)),
								result.getString(4)
						}));
					}
				} catch(SQLException ex) {
					ex.printStackTrace();
				}
			}
			fileIds.put(path, l);
		}
		return l.longValue();
	}
	
	public Long getFileId(String path, long revision) {
		String sql = "SELECT file_id FROM files " +
			"WHERE path=? AND revision_from<=? AND (revision_to>? OR revision_to IS NULL)"; // revision_to>=? 

		PreparedStatement statement = null;
		ResultSet result = null;
		try {
			statement = connection.prepareStatement(sql);
			statement.setString(1, path);
			statement.setLong(2, revision);
			statement.setLong(3, revision);
			result = statement.executeQuery();
			if(result.next()) {
				return new Long(result.getLong(1));
			}
			return null;
		} catch(SQLException e) {
			throw new CacheException(e);
		} finally {
			closeResultSet(result);
			closeStatement(statement);
		}
	}
	
	public long getLatestRevision() {
		String sql = "SELECT MAX(revision_id) from revisions";

		PreparedStatement statement = null;
		ResultSet result = null;
		try {
			statement = connection.prepareStatement(sql);
			result = statement.executeQuery();
			if(result.next()) {
				return result.getLong(1);
			}
			return 0L;
		} catch(SQLException e) {
			throw new CacheException(e);
		} finally {
			closeResultSet(result);
			closeStatement(statement);
		}
	}
	
	public List getNodes(long fileId) {
		String sql = "SELECT " +
			"revisions.revision_id, " +
			"revisions.author, " +
			"revisions.revision_date, " +
			"revisions.message," +
			"change_paths.path, " +
			"change_paths.action, " +
			"change_paths.copy_src_revision, " +
			"change_paths.copy_src_path " +
			"FROM change_paths, revisions " +
			"WHERE change_paths.revision_id=revisions.revision_id AND change_paths.file_id=? " +
			"ORDER BY change_paths.revision_id ASC";

		PreparedStatement statement = null;
		ResultSet result = null;
		try {
			statement = connection.prepareStatement(sql);
			statement.setLong(1, fileId);
			result = statement.executeQuery();
			List objects = new ArrayList();
			int i = 0;
			while(result.next()) {
				objects.add(mapRow(result, i));
				i++;
			}
			return objects;
		} catch(SQLException e) {
			throw new CacheException(e);
		} finally {
			closeResultSet(result);
			closeStatement(statement);
		}
	}
	
	private void executeUpdate(String sql) {
		try {
			connection.createStatement().executeUpdate(sql);
		} catch (SQLException e) {
			throw new CacheException("Error creating database structure", e);
		}
	}
	
	public Object mapRow(ResultSet resultSet, int i) throws SQLException {
		Node node = new Node();
		node.setRevision(resultSet.getLong(1));
		node.setAuthor(resultSet.getString(2));
		node.setRevisionDate(resultSet.getTimestamp(3));
		node.setMessage(resultSet.getString(4));
		node.setPath(resultSet.getString(5));
		node.setAction(resultSet.getString(6).charAt(0));
		node.setCopySrcRevision(resultSet.getLong(7));
		node.setCopySrcPath(resultSet.getString(8));
		return node;
	}
	
	public void clearCache() {
		executeUpdate("DELETE FROM change_paths");
		executeUpdate("DELETE FROM revisions");
		executeUpdate("DELETE FROM files");
	}

}
