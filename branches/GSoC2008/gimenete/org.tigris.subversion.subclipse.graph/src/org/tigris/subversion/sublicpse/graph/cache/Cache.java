package org.tigris.subversion.sublicpse.graph.cache;

import java.io.File;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Types;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.tigris.subversion.svnclientadapter.ISVNLogMessage;
import org.tigris.subversion.svnclientadapter.ISVNLogMessageChangePath;

public class Cache {

	private static final String DRIVER_CLASS_NAME = "org.apache.derby.jdbc.EmbeddedDriver";
	
	private Connection connection;
	
	public Cache(File f) throws Exception {
		String databaseName = f.toURL().toString().substring("file:/".length());
		
		Class.forName(DRIVER_CLASS_NAME);
		try {
			
			connection = 
				DriverManager.getConnection("jdbc:derby:"+databaseName);
			
		} catch(SQLException e) {
			// The database may not exist.
			connection = 
				DriverManager.getConnection("jdbc:derby:"+databaseName+";create=true");
			// Create tables
			createTablesAndIndexes();
		}	
	}
	
	private void createTablesAndIndexes() throws Exception {
		String s = "CREATE TABLE files (" +
				"file_id BIGINT NOT NULL GENERATED BY DEFAULT AS IDENTITY (START WITH 1, INCREMENT BY 1), " +
				"revision_from BIGINT NOT NULL, " +
				"revision_to BIGINT, " +
				"path VARCHAR(32672) NOT NULL)"; // no primary key
		
		executeUpdate(connection, s);

		s = "CREATE TABLE revisions (" +
				"revision_id BIGINT NOT NULL, " +
				"revision_date TIMESTAMP NOT NULL, " +
				"author VARCHAR(32672) NOT NULL, " +
				"message VARCHAR(32672) NOT NULL, " +
				"PRIMARY KEY (revision_id))";

		executeUpdate(connection, s);

		s = "CREATE TABLE change_paths (" +
				"path VARCHAR(32672) NOT NULL, " +
				"revision_id BIGINT NOT NULL, " +
				"copy_src_revision BIGINT, " +
				"copy_src_path VARCHAR(32672), " +
				"action CHAR(1) NOT NULL, " +
				"file_id BIGINT NOT NULL, "+
				"PRIMARY KEY (path, revision_id))";
		
		executeUpdate(connection, s);

		s = "ALTER TABLE change_paths ADD CONSTRAINT fk_change_revision " +
				"FOREIGN KEY (revision_id) REFERENCES revisions (revision_id)";
		
		executeUpdate(connection, s);

		s = "CREATE INDEX files_revision_from ON files (revision_from)";
		
		executeUpdate(connection, s);

		s = "CREATE INDEX files_revision_to ON files (revision_to)";
		
		executeUpdate(connection, s);

//		s = "CREATE INDEX files_path ON files (path)";
//		
//		executeUpdate(connection, s);

		s = "CREATE INDEX files_file_id ON files (file_id)";
		
		executeUpdate(connection, s);
		
	}
	
	public void close() {
		try {
			connection.close();
		} catch (SQLException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}
	
	public void update(ISVNLogMessage[] messages) throws Exception {
		Map fileIds = new HashMap();

		PreparedStatement insertRevision =
			connection.prepareStatement("INSERT INTO revisions (" +
					"revision_id, " +
					"revision_date, " +
					"author, " +
					"message" +
					") VALUES (?, ?, ?, ?)");

		PreparedStatement insertChangePath =
			connection.prepareStatement("INSERT INTO change_paths (" +
					"revision_id, " +
					"copy_src_revision, " +
					"copy_src_path, " +
					"action, " +
					"file_id, " +
					"path" +
					") VALUES (?, ?, ?, ?, ?, ?)");

		PreparedStatement insertFile =
			connection.prepareStatement("INSERT INTO files (" +
					"revision_from, " +
					"revision_to, " +
					"path" +
					") VALUES (?, ?, ?)", PreparedStatement.RETURN_GENERATED_KEYS);

		PreparedStatement insertCopyFile =
			connection.prepareStatement("INSERT INTO files (" +
					"file_id, "+
					"revision_from, " +
					"revision_to, " +
					"path" +
					") VALUES (?, ?, ?, ?)");

		PreparedStatement deleteFile =
			connection.prepareStatement("UPDATE files SET revision_to=? WHERE file_id=?");
		
		for (int i = 0; i < messages.length; i++) {
			ISVNLogMessage logMessage = messages[i];

			long revision = logMessage.getRevision().getNumber();
			
			insertRevision.setLong(1, revision);
			insertRevision.setTimestamp(2, new java.sql.Timestamp(logMessage.getDate().getTime()));
			insertRevision.setString(3, logMessage.getAuthor());
			insertRevision.setString(4, logMessage.getMessage());
			insertRevision.executeUpdate();
			
			ISVNLogMessageChangePath[] changedPaths = logMessage.getChangedPaths();
			
			for (int j = 0; j < changedPaths.length; j++) {
				ISVNLogMessageChangePath changePath = changedPaths[j];
				
				char action = changePath.getAction();
				long fileId;
				
				switch(action) {
				case 'A':
					if(changePath.getCopySrcRevision() == null) {
						insertFile.setLong(1, revision);
						insertFile.setNull(2, Types.BIGINT);
						insertFile.setString(3, changePath.getPath());
						insertFile.executeUpdate();

						ResultSet result = insertFile.getGeneratedKeys();
						if(result != null && result.next()) {
							fileId = result.getLong(1);
							fileIds.put(changePath.getPath(), new Long(fileId));
						} else {
							// TODO: throw exception
							System.err.println("FATAL! not generated key!");
							fileId = 0;
						}
					} else {
						// TODO: check if the result != null, though it must not be
						fileId = getFileId(changePath.getCopySrcPath(), changePath.getCopySrcRevision().getNumber()).longValue();
						insertCopyFile.setLong(1, fileId);
						insertCopyFile.setLong(2, revision);
						insertCopyFile.setNull(3, Types.BIGINT);
						insertCopyFile.setString(4, changePath.getPath());
						insertCopyFile.executeUpdate();
						fileIds.put(changePath.getPath(), new Long(fileId));
					}
					break;
				case 'M':
					fileId = getFileId(fileIds, changePath.getPath(), revision);
					break;
				case 'D':
					fileId = getFileId(fileIds, changePath.getPath(), revision);
					deleteFile.setLong(1, revision);
					deleteFile.setLong(2, fileId);
					deleteFile.executeUpdate();
					break;
				default:
					// TODO: assert or throw exception
					System.err.println("Unknown action: "+action);
					fileId = 0;
				}
				
				insertChangePath.setLong(1, revision);
				if(changePath.getCopySrcRevision() == null) {
					insertChangePath.setNull(2, Types.BIGINT);
				} else {
					insertChangePath.setLong(2, changePath.getCopySrcRevision().getNumber());
				}
				insertChangePath.setString(3, changePath.getCopySrcPath());
				insertChangePath.setString(4, Character.toString(action));
				insertChangePath.setLong(5, fileId);
				insertChangePath.setString(6, changePath.getPath());
				insertChangePath.executeUpdate();

				if(changePath.getCopySrcRevision() == null) {
					System.out.println(action+" "+fileId+" "+changePath.getPath());
				} else {
					System.out.println(action+" "+fileId+" "+changePath.getPath()+" from "+changePath.getCopySrcPath());
				}
			}
		}
	}
	
	private long getFileId(Map fileIds, String path, long revision) {
		Long l = ((Long) fileIds.get(path));
		if(l == null) {
			l = getFileId(path, revision);
			fileIds.put(path, l);
		}
		// TODO: 
		return l.longValue();
	}
	
	public Long getFileId(String path, long revision) {
		String sql = "SELECT file_id FROM files " +
			"WHERE path=? AND revision_from<=? AND (revision_to>=? OR revision_to IS NULL)";

		PreparedStatement statement = null;
		ResultSet result = null;
		try {
			statement = connection.prepareStatement(sql);
			statement.setString(1, path);
			statement.setLong(2, revision);
			statement.setLong(3, revision);
			result = statement.executeQuery();
			if(result.next()) {
				return new Long(result.getLong(1));
			}
			return null;
		} catch(SQLException e) {
			throw new CacheException(e);
		} finally {
			if(result != null) {
				try {
					result.close();
				} catch (SQLException e) {
					throw new CacheException(e);
				}
			}
			if(statement != null) {
				try {
					statement.close();
				} catch (SQLException e) {
					throw new CacheException(e);
				}
			}
		}
	}
	
	public long getLatestRevision() {
		String sql = "SELECT MAX(revision_id) from revisions";

		PreparedStatement statement = null;
		ResultSet result = null;
		try {
			statement = connection.prepareStatement(sql);
			result = statement.executeQuery();
			if(result.next()) {
				return result.getLong(1);
			}
			return 0L;
		} catch(SQLException e) {
			throw new CacheException(e);
		} finally {
			if(result != null) {
				try {
					result.close();
				} catch (SQLException e) {
					throw new CacheException(e);
				}
			}
			if(statement != null) {
				try {
					statement.close();
				} catch (SQLException e) {
					throw new CacheException(e);
				}
			}
		}
	}
	
	public List getNodes(long fileId) {
		String sql = "SELECT " +
			"revisions.revision_id, " +
			"revisions.author, " +
			"revisions.revision_date, " +
			"revisions.message," +
			"change_paths.path, " +
			"change_paths.action, " +
			"change_paths.copy_src_revision, " +
			"change_paths.copy_src_path " +
			"FROM change_paths, revisions " +
			"WHERE change_paths.revision_id=revisions.revision_id AND change_paths.file_id=? " +
			"ORDER BY change_paths.revision_id ASC";

		PreparedStatement statement = null;
		ResultSet result = null;
		try {
			statement = connection.prepareStatement(sql);
			statement.setLong(1, fileId);
			result = statement.executeQuery();
			List objects = new ArrayList();
			int i = 0;
			while(result.next()) {
				objects.add(mapRow(result, i));
				i++;
			}
			return objects;
		} catch(SQLException e) {
			throw new CacheException(e);
		} finally {
			if(result != null) {
				try {
					result.close();
				} catch (SQLException e) {
					throw new CacheException(e);
				}
			}
			if(statement != null) {
				try {
					statement.close();
				} catch (SQLException e) {
					throw new CacheException(e);
				}
			}
		}
	}
	
	private void executeUpdate(Connection connection, String sql) throws SQLException {
		System.out.println(sql);
		connection.createStatement().executeUpdate(sql);
	}
	
	public Object mapRow(ResultSet resultSet, int i) throws SQLException {
		Node node = new Node();
		node.setRevision(resultSet.getLong(1));
		node.setAuthor(resultSet.getString(2));
		node.setRevisionDate(resultSet.getTimestamp(3));
		node.setMessage(resultSet.getString(4));
		node.setPath(resultSet.getString(5));
		node.setAction(resultSet.getString(6).charAt(0));
		node.setCopySrcRevision(resultSet.getLong(7));
		node.setCopySrcPath(resultSet.getString(8));
		return node;
	}
	
	public static void main(String[] args) throws Exception {
		File f = new File("foo");
		new Cache(f);
	}

}
