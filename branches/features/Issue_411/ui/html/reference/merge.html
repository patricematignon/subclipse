<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<link rel="stylesheet" href="../book.css" charset="ISO-8859-1"
	type="text/css">
<title>Team &gt; Merge...</title>
</head>

<body>

<h1>Team &gt; Merge...</h1>

<p>Where branches are used to maintain separate lines of development, at
some stage you will want to merge the changes made on one branch back
into the trunk, or vice versa.</p>
<p>It is important to understand how branching and merging works in
Subversion before you start using it, as it can become quite complex. It
is highly recommended that you read the chapter <a
	href="http://svnbook.red-bean.com/en/1.1/ch04.html" target="_top"> <i>Branching
and Merging</i> </a> in the <a href="http://svnbook.red-bean.com/"
	target="_top"> <i>Subversion Book</i> </a> which gives a full
description, and many examples of how it is used.</p>
<p>An important point to remember is that Merge is closely related to
Diff. The merge process works by generating a list of differences
between two points in the repository, and applying those differences to
your working copy. For example if you want to merge the changes made in
revision N then you have to compare revision N with revision (N-1).
Novices often ask &#8220;Why do I have to subtract 1 from the start
revision.&#8221; Think of the underlying Diff process and it will become
clearer. To make this easier, when you use Show Log to select a range of
revisions to merge, Subclipse makes this adjustment for you
automatically.</p>
<p>In general it is a good idea to perform a merge into an unmodified
working copy. If you have made other changes in your WC, commit those
first. If the merge does not go as you expect, you may want to revert
the changes, and the Revert command will discard <em>all</em> changes
including any you made before the merge.</p>
<p>The only exception to this is files which are added to your working
copy by the Merge process. When you do a <tt>Revert</tt> and there are
additions in your working copy, those files are not removed. Instead
they become unversioned files in your working copy, and you have to
manually delete them before you attempt the merge again.</p>
<p>There are two common use cases for merging which are handled in
slightly different ways, as described below.</p>
<h3>Merging a Range of Revisions</h3>
<p>This method covers the case when you have made one or more revisions
to a branch (or to the trunk) and you want to port those changes across
to a different branch.</p>
<div><img src="../images/merge-dialog.jpg" alt="The Merge Dialog"></div>
<p>To merge revisions you need to go to a working copy of the branch in
which you want to receive the changes, often the trunk. Select Merge...
from the Team context menu.</p>
<div class="orderedlist">
<ol type="1">
	<li>
	<p>In the From: field enter the full folder URL of the branch or tag
	containing the changes you want to port into your working copy. You may
	also click Browse... to browse the repository and find the desired
	branch. If you have merged from this branch before, then just use the
	drop down list which shows a history of previously used URLs.</p>
	</li>
	<li>
	<p>Because you are porting a range of revisions from the same branch
	into your working copy, make sure the Use "From:" URL check box is
	checked.</p>
	</li>
	<li>
	<p>In the From Revision field enter the start revision number. This is
	the revision <em>before</em> the changes you want to merge. Remember
	that Subversion will create a diff file in order to perform the merge,
	so the start point has to be just before the first change you are
	interested in. For example, your log messages may look something like
	this:</p>
	<pre>
Rev Comments
39. Working on MyBranch
38. Working on trunk
37. Working on MyBranch
36. Create branch MyBranch
35. Working on trunk
34. Working on trunk
         ...
</pre>
	<p>If you now want to merge all the changes from MyBranch into the
	trunk you have to choose 36 as the From Revision, not 37 as you might
	think. If you select revision 37 as the start point, then the
	difference engine compares the end point with revision 37, and will
	miss the changes made in revision 37 itself. If that sounds
	complicated, don't worry, there is an easier way in Subclipse ...</p>
	<p>The easiest way to select the range of revisions you need is to
	click on Show Log, as this will list recent changes with their log
	comments. If you want to merge the changes from a single revision, just
	select that revision. If you want to merge changes from several
	revisions, then select that range (using the usual <b>Shift</b>-modifier).
	Click on OK and the revision numbers of the From revision and To
	revision in the Merge dialog will <em>both</em> be filled in for you.</p>
	<p>If you have already merged some changes from this branch, hopefully
	you will have made a note of the last revision merged in the log
	message when you committed the change. In that case, you can use Show
	Log for the Working Copy to trace that log message. Use the end point
	of the last merge as the start point for this merge. For example, if
	you have merged revisions 37 to 39 last time, then the start point for
	this merge should be revision 39.</p>
	</li>
	<li>
	<p>If you have not used Show Log to select the revision range, then you
	will need to set the To Revision manually. Enter the last revision
	number in the range you want to merge. Often this will be the HEAD
	revision, although it doesn't need to be - you may just want to merge a
	single revision.</p>
	<p>If other people may be committing changes then be careful about
	using the HEAD revision. It may not refer to the revision you think it
	does if someone else made a commit after your last update.</p>
	</li>
	<li>
	<p>Click OK to complete the merge.</p>
	</li>
</ol>
</div>
<p>The merge is now complete. It's a good idea to have a look at the
merge and see if it's as expected. Merging is usually quite complicated.
Conflicts often arise if the branch has drifted far from the trunk.</p>
<p>When you have tested the changes and come to commit this revision,
your commit log message should <em>always</em> include the revision
numbers which have been ported in the merge. If you want to apply
another merge at a later time you will need to know what you have
already merged, as you do not want to port a change more than once.
Unfortunately merge information is not stored by Subversion. For more
information about this, refer to <a
	href="http://svnbook.red-bean.com/en/1.1/ch04s03.html#svn-ch-4-sect-3.2.1"
	target="_top"> <i>Tracking Merges Manually</i> </a> in the <a
	href="http://svnbook.red-bean.com/" target="_top"> <i>Subversion Book</i>
</a></p>
<p>Branch management is important. If you want to keep this branch up to
date with the trunk, you should be sure to merge often so that the
branch and trunk do not drift too far apart. Of course, you should still
avoid repeated merging of changes, as explained above.</p>
<div style="margin-left: 0.5in; margin-right: 0.5in;">
<hr>
<h3>Important</h3>
<p>Subversion can't merge a file with a folder and vice versa - only
folders to folders and files to files. If you click on a file and open
up the merge dialog, then you have to give a path to a file in that
dialog. If you select a folder and bring up the dialog, then you must
specify a folder URL for the merge.</p>
<hr>
</div>
</div>
<h3>Merging Two Different Trees</h3>
<p>This method covers the case when you have made a feature branch as
discussed in the Subversion book. All trunk changes have been ported to
the feature branch, week by week, and now the feature is complete you
want to merge it back into the trunk. Because you have kept the feature
branch synchronized with the trunk, the latest versions of branch and
trunk will be absolutely identical except for your branch changes. So in
this special case, you would merge by comparing the branch with the
trunk.</p>
<p>To merge the feature branch back into the trunk you need to go to a
working copy of the trunk. Select Merge... from the context menu.</p>
<div class="orderedlist">
<ol type="1">
	<li>
	<p>In the From: field enter the full folder URL of the <em>trunk</em>.
	This may sound wrong, but remember that the trunk is the start point to
	which you want to add the branch changes. You may also click Browse...
	to browse the repository.</p>
	</li>
	<li>
	<p>Because you are comparing two different trees, make sure the Use
	"From:" URL check box is <em>not</em> checked.</p>
	</li>
	<li>
	<p>In the To: field enter the full folder URL of the feature branch.</p>
	</li>
	<li>
	<p>In both the From Revision field and the To Revision field, enter the
	last revision number at which the two trees were synchronized. If you
	are sure no-one else is making commits you can use the HEAD revision in
	both cases. If there is a chance that someone else may have made a
	commit since that synchronization, use the specific revision number to
	avoid losing more recent commits.</p>
	<p>You can also use Show Log to select the revision. Note that in this
	case you are not selecting a range of revisions, so the revision you
	select there is what will actually appear in the Revision field.</p>
	</li>
	<li>
	<p>Click OK to complete the merge.</p>
	</li>
</ol>
</div>
<p></p>
<p>In this case you will not need the feature branch again because the
new feature is now integrated into the trunk. The feature branch is
redundant and can be deleted from the repository if required.</p>
<h3>Previewing Merge Results</h3>
<p>If you are uncertain about the merge operation, you may want to
preview what will happen before you allow it to change your working
copy. There are two additional buttons to help you.</p>
<p>Unified Diff creates the diff file (remember that merge is based on
diff) and shows you which lines will be changed in your working copy
files. As this is a unified diff (patch) file it is not always easy to
read out of context, but for small scale changes it is often helpful.</p>
<p>Bare in mind that <tt>merge</tt> and <tt>diff</tt> are not exactly
the same. Merge is smarter and knows how to take into account things
like renames and moves. Diff always just shows the end result.
Conceptually they are very similar, but you cannot always just apply a
Unified Diff to a working copy and get the same results as merge.</p>
<p>Dry Run performs the merge operation, but does <em>not</em> modify
the working copy at all. It shows you a list of the files that will be
changed by a real merge, and notes those areas where conflicts will
occur. This information is shown in the SVN Console view.</p>
<h3>Undoing changes with Merge</h3>
<p>Another common use for <b>svn merge</b> is to roll back a change that
has already been committed. Suppose you're working away happily on a
working copy of <tt>/calc/trunk</tt>, and you discover that the change
made way back in revision 303, which changed <tt>integer.c</tt>, is
completely wrong. It never should have been committed. You can use <b>svn
merge</b> to &#8220;undo&#8221; the change in your working copy, and
then commit the local modification to the repository. All you need to do
is to specify a <em>reverse</em> difference:</p>
<pre>

$ svn merge -r 303:302 http://svn.example.com/repos/calc/trunk
U  integer.c

$ svn status
M  integer.c

$ svn diff
...
# verify that the change is removed
...

$ svn commit -m "Undoing change committed in r303."
Sending        integer.c
Transmitting file data .
Committed revision 350.
</pre>
<p>One way to think about a repository revision is as a specific group
of changes (some version control systems call these <i>changesets</i>).
By using the <tt>-r</tt> switch, you can ask <b>svn merge</b> to apply a
changeset, or whole range of changesets, to your working copy. In our
case of undoing a change, we're asking <b>svn merge</b> to apply
changeset #303 to our working copy <em>backwards</em>.</p>
<p>Keep in mind that rolling back a change like this is just like any
other <b>svn merge</b> operation, so you should use <b>svn status</b>
and <b>svn diff</b> to confirm that your work is in the state you want
it to be in, and then use <b>svn commit</b> to send the final version to
the repository. After committing, this particular changeset is no longer
reflected in the <tt>HEAD</tt> revision.</p>
<p>Again, you may be thinking: well, that really didn't undo the commit,
did it? The change still exists in revision 303. If somebody checks out
a version of the <tt>calc</tt> project between revisions 303 and 349,
they'll still see the bad change, right?</p>
<p>Yes, that's true. When we talk about &#8220;removing&#8221; a change,
we're really talking about removing it from <tt>HEAD</tt>. The original
change still exists in the repository's history. For most situations,
this is good enough. Most people are only interested in tracking the <tt>HEAD</tt>
of a project anyway. There are special cases, however, where you really
might want to destroy all evidence of the commit. (Perhaps somebody
accidentally committed a confidential document.) This isn't so easy, it
turns out, because Subversion was deliberately designed to never lose
information. Revisions are immutable trees which build upon one another.
Removing a revision from history would cause a domino effect, creating
chaos in all subsequent revisions and possibly invalidating all working
copies.</p>

<h3>Tasks:</h3>
<p><a href="../dailywork/branches.html">Maintaining branches with
Subclipse</a></p>
</body>
</html>
